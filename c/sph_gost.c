/* GOST R 34.11-94 implementation for SPHLIB */
#include <string.h>
#include "sph_gost.h"

/* Helper macros */
#define SWAP32(x) \
    ((((x) >> 24) & 0xFF) | (((x) >> 8) & 0xFF00) | \
     (((x) << 8) & 0xFF0000) | (((x) << 24) & 0xFF000000))

/* GOST S-box (RFC 5831) */
static const unsigned int gost_sbox[4][256] = {
    { /* S1 */
        0x4, 0xA, 0x9, 0x2, 0xD, 0x8, 0x0, 0xE, 0x6, 0xB, 0x1, 0xC, 0x7, 0xF, 0x5, 0x3,
        0xE, 0xB, 0x4, 0xC, 0x6, 0xD, 0xF, 0xA, 0x2, 0x3, 0x8, 0x1, 0x0, 0x7, 0x5, 0x9,
        0x5, 0x8, 0x1, 0xD, 0xA, 0x3, 0x4, 0x2, 0xE, 0xF, 0xC, 0x7, 0x6, 0x0, 0x9, 0xB,
        0x7, 0xD, 0xA, 0x1, 0x0, 0x8, 0x9, 0xF, 0xE, 0x4, 0x6, 0xC, 0xB, 0x2, 0x5, 0x3,
        0x6, 0xC, 0x7, 0x1, 0x5, 0xF, 0xD, 0x8, 0x4, 0xA, 0x9, 0xE, 0x0, 0x3, 0xB, 0x2,
        0x4, 0xB, 0xA, 0x0, 0x7, 0x2, 0x1, 0xD, 0x3, 0x6, 0x8, 0x5, 0x9, 0xC, 0xF, 0xE,
        0xD, 0xB, 0x4, 0x1, 0x3, 0xF, 0x5, 0x9, 0x0, 0xA, 0xE, 0x7, 0x6, 0x8, 0x2, 0xC,
        0x1, 0xF, 0xD, 0x0, 0x5, 0x7, 0xA, 0x4, 0x9, 0x2, 0x3, 0xE, 0x6, 0xB, 0x8, 0xC
    },
    { /* S2 */
        0x7, 0xC, 0xB, 0xD, 0xE, 0x4, 0x9, 0xF, 0x6, 0x0, 0x8, 0x5, 0x2, 0x1, 0xA, 0x3,
        0xA, 0x9, 0x7, 0xB, 0xF, 0x6, 0x0, 0x8, 0xC, 0x4, 0x5, 0xD, 0xE, 0x1, 0x2, 0x3,
        0xB, 0x5, 0x0, 0x7, 0x9, 0x2, 0xA, 0xD, 0x3, 0xE, 0x6, 0xC, 0x1, 0x8, 0xF, 0x4,
        0xD, 0xB, 0x7, 0x0, 0x9, 0x2, 0x1, 0xC, 0x5, 0xF, 0x8, 0xE, 0x4, 0xA, 0x6, 0x3,
        0x8, 0x6, 0x4, 0xB, 0x9, 0x3, 0xE, 0x5, 0x2, 0xD, 0xF, 0x0, 0xA, 0xC, 0x1, 0x7,
        0xF, 0x4, 0x2, 0x7, 0xC, 0x9, 0x8, 0x1, 0xD, 0xE, 0x0, 0x3, 0x6, 0xA, 0xB, 0x5,
        0xE, 0x7, 0xA, 0xC, 0xD, 0x1, 0x3, 0x9, 0x0, 0x2, 0xB, 0x4, 0xF, 0x8, 0x5, 0x6,
        0x1, 0xA, 0x6, 0x8, 0xF, 0xB, 0x0, 0x4, 0xC, 0x3, 0x5, 0x9, 0x7, 0xD, 0x2, 0xE
    },
    { /* S3 */
        0x2, 0x4, 0x3, 0x8, 0x9, 0xA, 0x5, 0x6, 0x7, 0x0, 0x1, 0xC, 0xD, 0xE, 0xF, 0xB,
        0xE, 0x6, 0x0, 0xB, 0x2, 0x3, 0x9, 0x1, 0xA, 0xF, 0x4, 0x5, 0xC, 0x8, 0xD, 0x7,
        0x3, 0x8, 0xD, 0x9, 0x6, 0xB, 0xF, 0x0, 0x2, 0x5, 0xC, 0xA, 0x4, 0xE, 0x1, 0x7,
        0xF, 0x8, 0xE, 0x9, 0x7, 0x2, 0x0, 0xD, 0xC, 0x6, 0x1, 0x5, 0xB, 0x4, 0x3, 0xA,
        0x2, 0x8, 0x9, 0x7, 0x5, 0xF, 0x0, 0xB, 0xC, 0x1, 0xD, 0xE, 0xA, 0x3, 0x6, 0x4,
        0x3, 0x9, 0x0, 0x5, 0xA, 0x8, 0xF, 0x7, 0xB, 0x2, 0xC, 0x1, 0xD, 0xE, 0x6, 0x4,
        0xB, 0xA, 0xF, 0x5, 0x0, 0xC, 0xE, 0x8, 0x6, 0x2, 0x3, 0x9, 0x1, 0x7, 0xD, 0x4,
        0x1, 0xD, 0x2, 0x9, 0x7, 0xA, 0x6, 0x0, 0x8, 0xC, 0x4, 0x5, 0xF, 0x3, 0xB, 0xE
    },
    { /* S4 */
        0x8, 0x4, 0xB, 0x1, 0x3, 0x5, 0x0, 0x9, 0x2, 0xE, 0xA, 0xC, 0xD, 0x6, 0x7, 0xF,
        0x0, 0x1, 0x2, 0xA, 0x4, 0xD, 0x5, 0xC, 0x9, 0x7, 0x3, 0xF, 0xB, 0x8, 0x6, 0xE,
        0xE, 0xC, 0x0, 0xA, 0x9, 0x2, 0xD, 0xB, 0x7, 0x5, 0x8, 0xF, 0x3, 0x6, 0x1, 0x4,
        0x7, 0x5, 0x0, 0xD, 0xB, 0x6, 0x1, 0x2, 0x3, 0xA, 0xC, 0xF, 0x4, 0xE, 0x9, 0x8,
        0x2, 0x7, 0xC, 0xF, 0x9, 0x5, 0xA, 0x0, 0xD, 0xE, 0x1, 0x3, 0x6, 0x4, 0xB, 0x8,
        0x4, 0xC, 0x7, 0x5, 0x1, 0x6, 0x9, 0xA, 0x0, 0xE, 0xD, 0x8, 0x2, 0xB, 0x3, 0xF,
        0xB, 0x9, 0x5, 0x1, 0xC, 0x3, 0xD, 0xE, 0x6, 0x4, 0x7, 0xF, 0x2, 0x0, 0x8, 0xA,
        0x3, 0xA, 0xD, 0xC, 0x1, 0x2, 0x0, 0xB, 0x7, 0x5, 0x9, 0x4, 0x8, 0xF, 0xE, 0x6
    }
};

/* GOST round function */
static unsigned int gost_f(unsigned int x) {
    unsigned int result = 0;
    int i;

    for (i = 0; i < 8; i++) {
        unsigned int sbox_index = (x >> (4 * i)) & 0x0F;
        unsigned int sbox_val = gost_sbox[i & 3][sbox_index];
        result |= (sbox_val << (4 * i));
    }

    return result;
}

/* Main GOST transformation */
static void gost_transform(sph_gost_context *sc, const unsigned char *data) {
    unsigned int n1, n2;
    unsigned int key[8];
    int i, j;

    /* Load message block */
    n1 = ((unsigned int)data[0]) | ((unsigned int)data[1] << 8) |
         ((unsigned int)data[2] << 16) | ((unsigned int)data[3] << 24);
    n2 = ((unsigned int)data[4]) | ((unsigned int)data[5] << 8) |
         ((unsigned int)data[6] << 16) | ((unsigned int)data[7] << 24);

    /* Prepare key */
    for (i = 0; i < 8; i++) {
        key[i] = sc->state[i];
    }

    /* 32 rounds of encryption */
    for (i = 0; i < 32; i++) {
        unsigned int t = n1 + key[i & 7];
        t = gost_f(t);
        t = (t << 11) | (t >> 21);
        t ^= n2;

        if (i < 31) {
            n2 = n1;
            n1 = t;
        } else {
            n2 = t;
        }
    }

    /* Update state */
    for (i = 0; i < 8; i++) {
        unsigned int t = 0;
        for (j = 0; j < 8; j++) {
            t ^= ((sc->state[j] >> (i * 4)) & 0x0F) << (j * 4);
        }
        t = gost_f(t);
        sc->state[i] ^= t;
    }

    /* Update sigma */
    for (i = 0; i < 8; i += 2) {
        unsigned int t1 = ((unsigned int)data[i*4]) | ((unsigned int)data[i*4+1] << 8) |
                         ((unsigned int)data[i*4+2] << 16) | ((unsigned int)data[i*4+3] << 24);
        unsigned int t2 = ((unsigned int)data[i*4+4]) | ((unsigned int)data[i*4+5] << 8) |
                         ((unsigned int)data[i*4+6] << 16) | ((unsigned int)data[i*4+7] << 24);
        sc->sigma[i/2] += t1 + t2;
    }

    /* Store result back to state */
    sc->state[0] ^= n1;
    sc->state[1] ^= n2;
}

/* Initialize GOST context */
void sph_gost_init(void *cc) {
    sph_gost_context *sc = (sph_gost_context *)cc;

    memset(sc, 0, sizeof(*sc));
    /* Initial state as per GOST R 34.11-94 */
    sc->state[0] = 0x01010101;
    sc->state[1] = 0x01010101;
    sc->state[2] = 0x01010101;
    sc->state[3] = 0x01010101;
    sc->state[4] = 0x01010101;
    sc->state[5] = 0x01010101;
    sc->state[6] = 0x01010101;
    sc->state[7] = 0x01010101;
}

/* Process data */
void sph_gost(void *cc, const void *data, size_t len) {
    sph_gost_context *sc = (sph_gost_context *)cc;
    const unsigned char *ptr = (const unsigned char *)data;

    sc->count += (unsigned long long)len << 3;

    if (sc->buf_ptr > 0) {
        size_t clen = (sizeof(sc->buffer) - sc->buf_ptr);
        if (clen > len) {
            clen = len;
        }
        memcpy(sc->buffer + sc->buf_ptr, ptr, clen);
        sc->buf_ptr += clen;
        ptr += clen;
        len -= clen;

        if (sc->buf_ptr == sizeof(sc->buffer)) {
            gost_transform(sc, sc->buffer);
            sc->buf_ptr = 0;
        }
    }

    while (len >= sizeof(sc->buffer)) {
        gost_transform(sc, ptr);
        ptr += sizeof(sc->buffer);
        len -= sizeof(sc->buffer);
    }

    if (len > 0) {
        memcpy(sc->buffer, ptr, len);
        sc->buf_ptr = len;
    }
}

/* Finalize and output hash */
void sph_gost_close(void *cc, void *dst) {
    sph_gost_close_internal(cc, 0, 0, dst, 0);
}

/* Finalize with extra bits */
void sph_gost_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst) {
    sph_gost_close_internal(cc, ub, n, dst, 1);
}

/* Internal finalization function */
static void sph_gost_close_internal(void *cc, unsigned ub, unsigned n, void *dst, int addbits) {
    sph_gost_context *sc = (sph_gost_context *)cc;
    unsigned char pad[32];
    size_t ptr;
    unsigned z;
    unsigned len;
    int i;

    ptr = sc->buf_ptr;

    if (addbits) {
        ub &= ((unsigned)1 << n) - 1U;
        sc->buffer[ptr++] = (unsigned char)ub;
        sc->count += n;
    }

    /* Padding */
    len = 32 - ptr;
    memset(pad, 0, sizeof(pad));
    pad[0] = 0x01;

    if (len <= 32) {
        memcpy(sc->buffer + ptr, pad, len);
        gost_transform(sc, sc->buffer);
        memcpy(sc->buffer, pad + len, 32 - len);
        sc->buf_ptr = 32 - len;
    } else {
        memcpy(sc->buffer + ptr, pad, 32);
        sc->buf_ptr += 32;
    }

    /* Process length */
    {
        unsigned char lenbuf[32];
        unsigned long long count = sc->count;

        memset(lenbuf, 0, sizeof(lenbuf));
        for (i = 0; i < 8; i++) {
            lenbuf[i] = (unsigned char)(count >> (i * 8));
        }

        sph_gost(sc, lenbuf, 32);
    }

    /* Final transform with sigma */
    {
        unsigned char sigmabuf[32];

        for (i = 0; i < 8; i++) {
            unsigned int s = sc->sigma[i];
            sigmabuf[i*4] = (unsigned char)s;
            sigmabuf[i*4+1] = (unsigned char)(s >> 8);
            sigmabuf[i*4+2] = (unsigned char)(s >> 16);
            sigmabuf[i*4+3] = (unsigned char)(s >> 24);
        }

        sph_gost(sc, sigmabuf, 32);
    }

    /* Output hash */
    if (dst != NULL) {
        unsigned char *out = (unsigned char *)dst;
        for (i = 0; i < 8; i++) {
            unsigned int v = sc->state[i];
            out[i*4] = (unsigned char)v;
            out[i*4+1] = (unsigned char)(v >> 8);
            out[i*4+2] = (unsigned char)(v >> 16);
            out[i*4+3] = (unsigned char)(v >> 24);
        }
    }

    /* Reset context */
    sph_gost_init(cc);
}

/* Test vectors for verification */
static const char *test_vectors[] = {
    /* Empty string */
    "ce85b99cc46752fffee35cab9a7b0278abb4c2d2055cff685af4912c49490f8d",
    /* "a" */
    "d42c539e367c66e9c88a801f6649349c21871b4344c6a573f849fdce62f314dd",
    /* "abc" */
    "b285056dbf18d7392d7677369524dd14747459ed8143997e163b2986f92fd42c",
    /* "message digest" */
    "bc6041dd2aa401ebfa6e9886734174febdb4729aa972d60f549ac39b29721ba0",
    NULL
};
